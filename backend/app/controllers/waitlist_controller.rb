=begin

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

The version of the OpenAPI document: 1.0.0
Generated by: https://github.com/openapitools/openapi-generator.git

=end
class WaitlistController < ApplicationController
  include ActionController::Live
  before_action :set_party_and_restaurant, only: [ :check_in, :position_stream, :destroy ]

  # Checkin a party and adjust the number of available seats.
  def check_in
    # Verify the party position on the waitlist
    if @restaurant.waitlist.first._id != @party._id or @restaurant.current_capacity < @party.size
      render json: { message: "Check-in isn't available for this party yet." }, status: :forbidden
      return
    end

    # Seat the party, in other words takes available seats.
    @restaurant.current_capacity -= @party.size
    @restaurant.save

    # Queue the cleaning of the table.
    RestaurantCleaningTableJob.set(wait: (3 * @party.size).seconds).perform_later(@restaurant._id, @party.size)

    # The party is no longer needed.
    @party.destroy

    render status: :ok
  end

  # Open an SSE channel to update the client on the party position in the waitlist.
  # Will shut itself when the party can checking. The position is checked every 2 second but the client
  # is updated only when the position or checking status changes.
  def position_stream
    response.headers["Content-Type"] = "text/event-stream"
    response.headers["Last-Modified"] = Time.now.httpdate
    sse = SSE.new(response.stream, retry: 300, event: "open")

    current = -1
    check_in_allowed = false

    loop do
      restaurant = Restaurant.find(@restaurant._id)
      party_position = restaurant.waitlist.find_index(@party)
      check_in_allowed = (party_position == 0 and restaurant.current_capacity >= @party.size)

      if current != party_position or check_in_allowed
        sse.write({ position: restaurant.waitlist.find_index(@party), check_in_allowed: check_in_allowed }, event: "message")
      end

      sleep 2
      current = party_position
      sse.write("", event: "heartbeat")
      break if party_position == nil or check_in_allowed == true
    end

  rescue ActionController::Live::ClientDisconnected
    sse.close
  ensure
    sse.close
  end

  # Add the party to the restaurant waitlist.
  def join
    # Retrieve the original restaurant
    @restaurant = Restaurant.find(params.expect(:restaurant_uuid))
    party_params = get_party_params

    if party_params[:party_size] > @restaurant.max_party_size
      return render status: :unprocessable_content, json: { "message" => "Party size cannot exceed #{@restaurant.max_party_size}" }
    end

    party = Party.new(party_params)

    @restaurant.waitlist.push(party)

    if @restaurant.save
      render json: party, status: :created
    end

    # render json: @party
  end

  # Delete the party from the waitlist.
  def destroy
    @party.destroy
    render status: :no_content
  end

  private

  # Retrieve the restaurant based on the party Uuid
  def set_restaurant_from_party
    @restaurant = Restaurant.find_by("waitlist._id" => params.expect(:uuid))
  end

  def set_party_and_restaurant
    @restaurant = set_restaurant_from_party
    @party = @restaurant.waitlist.find(params[:uuid])
  end

  # Confirm presence of :name, :capacity, and optional :max_party_size
  def get_party_params
    party_params = params.expect(waitlist: [ :name, :party_size ])
    if party_params[:name].blank? or party_params[:party_size].blank?
      raise ActionController::ParameterMissing.new("", keys = party_params[:name].blank? ? "name" : "party_size")
    end
    party_params
  end
end
